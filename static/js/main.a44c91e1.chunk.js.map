{"version":3,"sources":["App.tsx","reportWebVitals.ts","index.tsx"],"names":["RESNET18_CLIENT_MODEL_URL","RESNET18_SERVER_MODEL_URL","App","props","session","preprocessImage","img","orgWidth","width","orgHeight","height","resizedHeight","resizedWidth","console","log","canvas","document","createElement","getContext","drawImage","data","getImageData","dataFromImage","ndarray","Float32Array","dataProcessed","ops","assign","pick","divseq","subseq","Tensor","greyscaleToRGBA","greyscaleArray","rgbaArray","Uint8ClampedArray","shape","counter","r","c","val","get","classifyImage","a","inputImg","getElementById","setState","status","class","state","modelLoaded","InferenceSession","backendHint","loadModel","splitLayer","imgTensor","run","clientOutputMap","splitActivation","values","next","value","dims","npActivation","channels","previewContainer","innerHTML","id","featureMap","Math","floor","random","clonedMap","slice","stride","offset","mulseq","sup","ctx","idata","createImageData","set","putImageData","preview","className","toString","src","toDataURL","appendChild","setTimeout","requestOptions","method","headers","body","JSON","stringify","Array","from","fetch","then","response","json","error","updatePreview","style","display","file","files","imageURL","URL","createObjectURL","updateRangePreview","parseInt","textAlign","type","min","this","max","step","onChange","disabled","accept","onClick","Component","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.a44c91e1.chunk.js","sourcesContent":["\nimport { Component } from 'react';\nimport {Tensor, InferenceSession} from 'onnxjs';\nimport * as onnxx from 'onnxjs';\nimport ndarray, { NdArray } from \"ndarray\";\nimport ops from 'ndarray-ops';\nimport './App.css';\n\n\ninterface State {\n  status: string, // status message displayed to user\n  modelLoaded: boolean, // flag to decide whether client model needs to be loaded -- needs to be loaded only during the first inference\n  class: string,  // output of resnet model, identified ImageNet class of the image\n  imageURL: string,\n  splitLayer: number // layer that determines split between client and server omdel\n}\n\ninterface Props {}\n\n// the client model will be downloaded and used by ONNX\nconst RESNET18_CLIENT_MODEL_URL = 'https://splitlearning.mit.edu/SplitLearningInference/client_models/';\n// the server model will be sent activations through a POST request\nconst RESNET18_SERVER_MODEL_URL = 'https://sl-demo-backend.herokuapp.com/inference';\n\nclass App extends Component<Props, State> {\n\n  session:InferenceSession = null;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = {\n        status: null,\n        modelLoaded: false,\n        class: null,\n        imageURL: null,\n        splitLayer: 5\n    };\n  }\n\n  /**\n   * Preprocessing (resize, crop, rearrange, normalize, totensor) image from canvas for ResNet inference\n   * @param img: HTMLImageElement\n   * @returns \n   */\n  preprocessImage = (img: HTMLImageElement) => {\n    // scale image so that the smaller dimension is 224 px\n    var orgWidth = img.width;\n    var orgHeight = img.height;\n    var resizedHeight = 224;\n    var resizedWidth = 224;\n    if (orgWidth > orgHeight) {\n      resizedWidth = (orgWidth / orgHeight) * 224;\n    } else if (orgWidth < orgHeight) {\n      resizedHeight = (orgHeight / orgWidth) * 224;\n    }\n    console.log(\"Resized (\" + orgWidth + \"px, \" + orgHeight + \"px) Image to (\" + resizedWidth + \"px, \" + resizedHeight + \"px)\")\n\n    // draw image on an HTML canvas\n    var canvas = document.createElement('canvas');\n    canvas.width = resizedWidth;\n    canvas.height = resizedHeight;\n    canvas.getContext('2d').drawImage(img, 0, 0, resizedWidth, resizedHeight);\n\n    // Get pixel data from a 224 x 224 crop of image \n    if (resizedHeight > resizedWidth) {\n      // vertically centered crop works best for vertical images\n      var data = canvas.getContext('2d').getImageData(0, (resizedHeight - 224)/2, 224, 224 + (resizedHeight - 224)/2).data;\n    } else {\n      // left crop works best for horizontal images\n      var data = canvas.getContext('2d').getImageData(0, 0, 224, 224).data;\n    }\n\n    // Rearrange values to a 3 channel 224 by 224 matrix (ignoring a value given by context.getImageData) \n    const dataFromImage = ndarray(new Float32Array(data), [224, 224, 4]);\n    const dataProcessed = ndarray(new Float32Array(224 * 224 * 3), [1, 3, 224, 224]);\n    ops.assign(dataProcessed.pick(0, 0, null, null), dataFromImage.pick(null, null, 2));\n    ops.assign(dataProcessed.pick(0, 1, null, null), dataFromImage.pick(null, null, 1));\n    ops.assign(dataProcessed.pick(0, 2, null, null), dataFromImage.pick(null, null, 0));\n\n    // Convert values from 0-255 to 0-1\n    ops.divseq(dataProcessed, 255);\n\n    // Normalize values so the mean and std for (r, g, b) is (0.485, 0.456, 0.406) and (0.229, 0.224, 0.225) respectively\n    ops.subseq(dataProcessed.pick(0, 0, null, null), 0.485);\n    ops.subseq(dataProcessed.pick(0, 1, null, null), 0.456);\n    ops.subseq(dataProcessed.pick(0, 2, null, null), 0.406);\n    ops.divseq(dataProcessed.pick(0, 0, null, null), 0.229);\n    ops.divseq(dataProcessed.pick(0, 1, null, null), 0.224);\n    ops.divseq(dataProcessed.pick(0, 2, null, null), 0.225);\n\n    // Convert finalized data to ONNX Tensor\n    var imgTensor = new Tensor((dataProcessed.data as Float32Array), 'float32', [1, 3, 224, 224])\n\n    return imgTensor;\n  }\n\n  greyscaleToRGBA = (greyscaleArray: NdArray) => {\n    /**\n     * To convert greyscale to RGBA, replace the r, g, b values with the greyscale value\n     */\n    let rgbaArray = new Uint8ClampedArray(greyscaleArray.shape[0] * greyscaleArray.shape[1] * 4);\n    let counter = 0;\n    const width = greyscaleArray.shape[0];\n    const height = greyscaleArray.shape[1];\n    for (let r = 0; r < width; r++) {\n      for (let c = 0; c < height; c++) {\n        const val = greyscaleArray.get(r, c)\n        rgbaArray[counter] = val; // r\n        rgbaArray[counter + 1] = val; // g\n        rgbaArray[counter + 2] = val;  // b\n        rgbaArray[counter + 3] = 255; // a\n        counter += 4\n      }\n    }\n    return rgbaArray;\n  }\n\n  classifyImage = async () => {\n    var inputImg = document.getElementById('imageView') as HTMLImageElement;\n\n    // Load the ResNet18 Client ONNX model on first inference only\n    this.setState({\n      status: \"Loading client model...\",\n      class: null // clear class\n    });\n    if (!this.state.modelLoaded) {\n      this.session = new InferenceSession({ backendHint: 'cpu' })\n      await this.session.loadModel(RESNET18_CLIENT_MODEL_URL + \"resnet18_client_sl_\" + this.state.splitLayer + \".onnx\");\n      console.log(\"loaded client model from \" + RESNET18_CLIENT_MODEL_URL + \"resnet18_client_sl_\" + this.state.splitLayer + \".onnx\")\n      this.setState({\n        modelLoaded: true\n      });\n    }\n\n    if (inputImg) {\n      // Preprocess Image and perform client model inference\n      this.setState({\n        status: \"Client model inference...\"\n      });\n      var imgTensor = this.preprocessImage(inputImg);\n      const clientOutputMap = await this.session.run([imgTensor])\n      const splitActivation = clientOutputMap.values().next().value;\n      console.log(\"Dimensions: \" + splitActivation.dims)\n\n      let npActivation = ndarray(splitActivation.data, splitActivation.dims)\n      const channels = npActivation.shape[1]\n      const width = npActivation.shape[2]\n      const height = npActivation.shape[3]\n      const previewContainer = document.getElementById(\"previews\")\n      // clear past previews\n      previewContainer.innerHTML = \"\";\n      for (let id = 0; id < 10; id++) {\n        // Clone the activation\n        const featureMap = npActivation.pick(0, Math.floor(Math.random() * channels), null, null);\n        let clonedMap = ndarray((featureMap.data as Float32Array).slice(), featureMap.shape, featureMap.stride, featureMap.offset)\n        ops.mulseq(clonedMap, 255.0/(ops.sup(clonedMap)));\n        let rgbaArray = this.greyscaleToRGBA(clonedMap);\n\n        var canvas = document.createElement('canvas'),\n        ctx = canvas.getContext('2d');\n\n        canvas.width = width;\n        canvas.height = height;\n\n        // create imageData object\n        var idata = ctx.createImageData(width, height);\n\n        // set our buffer as source\n        idata.data.set(rgbaArray);\n\n        // update canvas with new data\n        ctx.putImageData(idata, 0, 0);\n\n        // show feature maps\n        const preview = document.createElement(\"img\")\n        preview.className = \"preview\"\n        preview.id = id.toString();\n        preview.width = width;\n        preview.height = height;\n        preview.src = canvas.toDataURL();\n        previewContainer.appendChild(preview)\n      }\n\n      \n      // Wait a few seconds so user can view the feature maps\n      setTimeout(\n        () => {\n          // Perform server model inference on the split activation\n          this.setState({\n            status: \"Sending split activations for server model inference (Split Layer=\" + this.state.splitLayer +\") ...\"\n          });\n          const requestOptions = {\n              method: 'POST',\n              headers: { 'Content-Type': 'application/json' },\n              body: JSON.stringify({dims: splitActivation.dims, data: Array.from(splitActivation.data), splitLayer: this.state.splitLayer})\n          };\n          console.log(\"Sending to \" + RESNET18_SERVER_MODEL_URL + \" with split layer of \" + this.state.splitLayer)\n          fetch(RESNET18_SERVER_MODEL_URL, requestOptions)\n              .then(response => response.json())\n              .then(data => {\n                // hide feature maps\n                // Display predicted class through app state\n                this.setState({status: null, class: data.class});\n              });\n        }, 2000\n      )\n\n      \n    } else {\n      console.error(\"There was an error accessing the uploaded image. Please try again.\")\n    }\n  }\n\n  /**\n   * Displays an image preview to the user whenever they upload an image\n   */\n  updatePreview = () => {\n    document.getElementById(\"imageLoader\").style.display = \"block\";\n    const file = (document.getElementById(\"inputImage\") as HTMLInputElement).files[0];\n    console.log(file)\n    if (file) {\n        this.setState({ imageURL: URL.createObjectURL(file) });\n    }\n    document.getElementById(\"imageLoader\").style.display = \"none\";\n  }\n\n  updateRangePreview = () => {\n    const splitLayer = (document.getElementById(\"splitLayerRange\") as HTMLInputElement).value;\n    this.setState({ modelLoaded: false, splitLayer: parseInt(splitLayer) })\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <h1>ResNet18 Split Inference Demo</h1>\n          <p className=\"desc\">\n            A pre-trained ResNet18 model is split into <b>two</b> separate models â€” <b>client</b> (Alice) and <b>server</b> (Bob).\n          </p>\n          <img id=\"splitInferenceDiagram\" src=\"split_inference_diagram.png\"/>\n          <p className=\"desc\">\n            Your <b>uploaded image</b> is sent through the client model which returns the <b>split activations</b> of a cut layer within the full model. \n            <br />\n            <br />\n            These activations are sent to a server where the remaining of the inference is completed. The <b>output tensor</b> is then sent back to the client. \n            <br />\n            <br />\n            This allows you to perform <b>inference</b> on a model present on a <b>third party</b> server while <b>preserving your image's privacy</b>.\n          </p>\n          <div style={{textAlign: 'left'}}>\n            <span>Split Layer: &nbsp;</span><input id=\"splitLayerRange\" type=\"range\" min=\"2\" value={this.state.splitLayer} max=\"7\" step=\"1\" onChange={this.updateRangePreview} disabled={(this.state.status !== null)}/>&nbsp;<span id=\"splitLayerPreview\">{this.state.splitLayer}</span>\n            <br />\n            <span>Input Image: &nbsp;</span><input onChange={this.updatePreview} type=\"file\" id=\"inputImage\" accept=\"image/jpeg\"  disabled={(this.state.status !== null)}/>\n          </div>\n          <br />\n          <div id=\"imageLoader\" className=\"loader\"></div>\n          <img id=\"imageView\" src={this.state.imageURL} style={{display: (this.state.imageURL === null) ? \"none\" : \"block\"}}/>\n          <br />\n          <input type=\"submit\" onClick={this.classifyImage} value=\"Classify Image\" id=\"submit\" />\n          <br />\n          \n          {(this.state.status !== null || this.state.class) ? (<div>\n            <hr className=\"divider\" />\n            { this.state.class ? (\n              <div className=\"output\">\n                <p>Class: {this.state.class}</p>\n              </div>\n            ) : (\n              <p className=\"loadMsg\">{this.state.status}</p>\n            ) }\n            <br />\n            <span>Split Activations: &nbsp;&nbsp;</span>\n            <div id=\"previews\"></div>\n          </div>) : (<span></span>)}\n        </header>\n      </div>\n    )\n  }\n\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  \n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}